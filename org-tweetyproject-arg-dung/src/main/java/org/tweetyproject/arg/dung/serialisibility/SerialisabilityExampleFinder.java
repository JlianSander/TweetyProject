/*
 *  This file is part of "TweetyProject", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  TweetyProject is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2023 The TweetyProject Team <http://tweetyproject.org/contact/>
 */
package org.tweetyproject.arg.dung.serialisibility;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;

import org.tweetyproject.arg.dung.principles.Principle;
import org.tweetyproject.arg.dung.reasoner.AbstractExtensionReasoner;
import org.tweetyproject.arg.dung.semantics.Extension;
import org.tweetyproject.arg.dung.semantics.Semantics;
import org.tweetyproject.arg.dung.syntax.Argument;
import org.tweetyproject.arg.dung.syntax.DungTheory;
import org.tweetyproject.arg.dung.syntax.TransitionState;
import org.tweetyproject.arg.dung.util.DefaultDungTheoryGenerator;
import org.tweetyproject.arg.dung.util.DungTheoryGenerationParameters;
import org.tweetyproject.commons.postulates.Postulate;
import org.tweetyproject.commons.postulates.PostulateEvaluatable;

/**
 * This class represents a generator for exemplary frameworks with serialisable extensions.
 * The objects of this class verify that the generated frameworks and their analyses comply specified conditions.
 *
 * @see DefaultDungTheoryGenerator
 * @see org.tweetyproject.arg.dung.learning.ExampleFinder
 *
 * @author Julian Sander
 * @version TweetyProject 1.23
 *
 */
public class SerialisabilityExampleFinder {

	private DefaultDungTheoryGenerator generator;
	private DungTheoryGenerationParameters parameters;
	private HashMap<Principle, AbstractExtensionReasoner> conditionsFramework = new HashMap<Principle, AbstractExtensionReasoner>();
	private int maxNumberTryGenerateFramework = 10;
	private HashMap<Postulate<Argument>, PostulateEvaluatable<Argument>> conditionsAnalysis = new HashMap<Postulate<Argument>, PostulateEvaluatable<Argument>>();
	//private HashMap<Postulate<Extension<Argument>>, PostulateEvaluatable<Extension<Argument>>> conditionsAnalysis = new HashMap<Postulate<Extension<Argument>>, PostulateEvaluatable<Extension<Argument>>>();
	//private HashMap<Postulate<TransitionState>, PostulateEvaluatable<TransitionState>> conditionsAnalysis = new HashMap<Postulate<TransitionState>, PostulateEvaluatable<TransitionState>>();

	/**
	 *
	 * @param numberOfArguments {@link DungTheoryGenerationParameters#numberOfArguments}
	 * @param attackProbability {@link DungTheoryGenerationParameters#attackProbability}
	 * @param avoidSelfAttacks {@link DungTheoryGenerationParameters#avoidSelfAttacks}
	 * @param maxNumberTryGenerateFramework Number how often the generator can retry to generate a framework complied to the conditions, before aborting the process.
	 */
	public SerialisabilityExampleFinder(int numberOfArguments, double attackProbability, boolean avoidSelfAttacks, int maxNumberTryGenerateFramework) {
		this.parameters = new DungTheoryGenerationParameters();
		this.changeParameterNumberOfArguments(numberOfArguments);
		this.changeParameterAttackProbability(attackProbability);
		this.changeParameterSelfAttacks(avoidSelfAttacks);
		if(maxNumberTryGenerateFramework > 0) {
			this.maxNumberTryGenerateFramework = maxNumberTryGenerateFramework;
		}

		this.generator = new DefaultDungTheoryGenerator(this.parameters);
	}

	/**
	 * Adds a specified principle as a condition, which is fulfilled by all frameworks generated by this class.
	 * The specified reasoner will check if the principle is satisfied.
	 * @param condition Principle, which will be fulfilled by all frameworks generated by this class.
	 * @param reasonerToCheck Reasoner, which will be used to check whether the condition is satisfied or not.
	 */
	public void addConditionForFramework(Principle condition, AbstractExtensionReasoner reasonerToCheck) {
		this.conditionsFramework.put(condition, reasonerToCheck);
	}
	
	/**
	 * Adds a specified postulate as a condition, which is satisfied by all analyses of the serialisable extensions 
	 * wrt the specified semantics, for all generated frameworks. The parameter evaluation is used to verify the condition.
	 * @param condition condition, which is satisfied by all analyses, or rather the graph resulting from the analysis
	 * @param evaluation Used to verify if the condition is satisfied by a analysis or rather the graph resulting from the analysis
	 */
	public void addCOnditionForAnalysis(Postulate<Argument> condition, PostulateEvaluatable<Argument> evaluation) {
		this.conditionsAnalysis.put(condition, evaluation);
	}

	/**
	 * Changes the Parameter to generate exemplary serializability analyses.
	 * @param attackProbability {@link DungTheoryGenerationParameters#attackProbability}
	 */
	public void changeParameterAttackProbability(double attackProbability) {
		this.parameters.attackProbability = attackProbability;
	}

	/**
	 * Changes the Parameter to generate exemplary serializability analyses.
	 * @param numberOfArguments {@link DungTheoryGenerationParameters#numberOfArguments}
	 */
	public void changeParameterNumberOfArguments(int numberOfArguments) {
		this.parameters.numberOfArguments = numberOfArguments;
	}

	/**
	 * Changes the Parameter to generate exemplary serializability analyses.
	 * @param seed {@link org.tweetyproject.argumentation.util.DungTheoryGenerator#setSeed}
	 */
	public void changeParameterSeed(long seed) {
		this.generator.setSeed(seed);
	}

	/**
	 * Changes the Parameter to generate exemplary serializability analyses.
	 * @param avoidSelfAttacks {@link DungTheoryGenerationParameters#avoidSelfAttacks}
	 */
	public void changeParameterSelfAttacks(boolean avoidSelfAttacks) {
		this.parameters.avoidSelfAttacks = avoidSelfAttacks;
	}

	/**
	 * Creates an exemplary serializability analysis of a generated argumentation frameworks..
	 *
	 * @param semanticsForSerializing Semantics of the extensions created during the serializing process, which will be analyzed.
	 * @param abortFrameworkNotComply If TRUE, an exception is thrown and the method aborted whenever no framework compliant to the conditions can be generated. If FALSE, returns NULL if no framework can be generated.
	 * @param abortAnalysisNotComply If TRUE, an exception is thrown and the method aborted whenever an analysis doesn't comply the conditions. If FALSE, returns NULL if analysis doesn't satisfies conditions.
	 * @return Analysis result of a randomly generated exemplary problem.
	 * @throws ExceptionNotSatisfiedPostulate Throws an exception, if no framework compliant to the conditions could be created within the specified number of maximum attempts
	 */
	public ContainerTransitionStateAnalysis findExample(
			Semantics semanticsForSerializing, 
			boolean abortFrameworkNotComply, 
			boolean abortAnalysisNotComply) throws ExceptionNotSatisfiedPostulate {

		DungTheory generatedFramework = this.generateFramework(abortFrameworkNotComply);
		
		if(generatedFramework != null) {
			return deriveAnalysis(semanticsForSerializing, generatedFramework, abortAnalysisNotComply);
		}
		else {
			return null;
		}
	}

	

	/**
	 * Creates exemplary serializability analyses of generated argumentation frameworks.
	 *
	 * @param semanticsForSerializing Semantics of the extensions created during the serializing process, which will be analyzed.
	 * @param numberOfExamples Number of examples generated.
	 * @param abortFrameworkNotComply If TRUE, an exception is thrown and the method aborted whenever no framework compliant to the conditions can be generated. If FALSE, skips settings for non compliant frameworks and returns less output.
	 * @param abortAnalysisNotComply If TRUE, an exception is thrown and the method aborted whenever an analysis doesn't comply the conditions. If FALSE, skips non compliant analysis and returns less output.
	 * @return Array of analysis results, analyzing each a different randomly generated exemplary argumentation framework.
	 * @throws ExceptionNotSatisfiedPostulate Throws an exception, if no framework compliant to the conditions could be created within the specified number of maximum attempts
	 */
	public ContainerTransitionStateAnalysis[] findExample(
			Semantics semanticsForSerializing, 
			int numberOfExamples,
			boolean abortFrameworkNotComply, 
			boolean abortAnalysisNotComply) throws ExceptionNotSatisfiedPostulate {
		
		int numberExamplesLeft =  numberOfExamples;
		HashSet<ContainerTransitionStateAnalysis> results = new HashSet<ContainerTransitionStateAnalysis>();
		
		do {
			ContainerTransitionStateAnalysis analysis = this.findExample(semanticsForSerializing, abortFrameworkNotComply, abortAnalysisNotComply);
			if(analysis != null) results.add(analysis);
			numberExamplesLeft--;
		} while (numberExamplesLeft > 0);
		
		return results.toArray(new ContainerTransitionStateAnalysis[0]);
	}

	/**
	 * Creates exemplary argumentation frameworks and analyzes their serialisable extensions.
	 * The method generates frameworks starting with the specified number of arguments,
	 * and increasing this number by the specified increment
	 * as long as the number stays lower or equal than the specified maximum number of arguments (inclusive boundary).
	 *
	 * @param semanticsForSerializing Semantics of the extensions created during the serializing process, which will be analyzed.
	 * @param numberOfArgumentsStart Number of Arguments of the first framework, which will be generated as an example.
	 * @param maxNumberOfArguments Maximum number of arguments of any framework generated by this method.
	 * @param numberOfExamplesPerIncrement Number of examples created with the same number of arguments.
	 * @param incrementForNumberOfArguments Increment by which the number of arguments is increased each time.
	 * @param abortFrameworkNotComply If TRUE, an exception is thrown and the method aborted whenever no framework compliant to the conditions can be generated. If FALSE, skips settings for non compliant frameworks and returns less output.
	 * @param abortAnalysisNotComply If TRUE, an exception is thrown and the method aborted whenever an analysis doesn't comply the conditions. If FALSE, skips non compliant analysis and returns less output.
	 * @return Array of analysis results, analyzing each a different randomly generated exemplary argumentation framework.
	 * @throws ExceptionNotSatisfiedPostulate Throws an exception, if no framework compliant to the conditions could be created within the specified number of maximum attempts
	 */
	public  ContainerTransitionStateAnalysis[] findExample(
			Semantics semanticsForSerializing,
			int numberOfArgumentsStart,
			int maxNumberOfArguments,
			int numberOfExamplesPerIncrement,
			int incrementForNumberOfArguments,
			boolean abortFrameworkNotComply, 
			boolean abortAnalysisNotComply) throws ExceptionNotSatisfiedPostulate {
		
		ArrayList<ContainerTransitionStateAnalysis> results = new ArrayList<ContainerTransitionStateAnalysis>();
		
		for (int i = numberOfArgumentsStart; i <= maxNumberOfArguments; i += incrementForNumberOfArguments) {
			this.changeParameterNumberOfArguments(i);
			for (int j = 0; j < numberOfExamplesPerIncrement; j++) {
				ContainerTransitionStateAnalysis analysis = this.findExample(semanticsForSerializing, abortFrameworkNotComply, abortAnalysisNotComply);
				if(analysis != null) results.add(analysis);
			}
		}
		return results.toArray(new ContainerTransitionStateAnalysis[0]);
	}

	/**
	 * Generates argumentation frameworks and analyzes their serialisable extensions regarding the specified semantics.
	 * @param semanticsForSerializing Array of semantics, used to create the different analyses.
	 * @param numberOfExamples Number of exemplary frameworks, which will be generated.
	 * @param abortFrameworkNotComply If TRUE, an exception is thrown and the method aborted whenever no framework compliant to the conditions can be generated. If FALSE, skips settings for non compliant frameworks and returns less output.
	 * @param abortAnalysisNotComply If TRUE, an exception is thrown and the method aborted whenever an analysis doesn't comply the conditions. If FALSE, skips non compliant analysis and returns less output.
	 * @return Frameworks mapped to the associated analyses using different semantics
	 * @throws ExceptionNotSatisfiedPostulate Throws an exception, if no framework compliant to the conditions could be created within the specified number of maximum attempts
	 */
	public LinkedHashMap<DungTheory, ContainerTransitionStateAnalysis[]> findExampleForDifferentSemantics(
			Semantics[] semanticsForSerializing,
			int numberOfExamples,
			boolean abortFrameworkNotComply, 
			boolean abortAnalysisNotComply) throws ExceptionNotSatisfiedPostulate{
		
		LinkedHashMap<DungTheory, ContainerTransitionStateAnalysis[]> results = new LinkedHashMap<DungTheory, ContainerTransitionStateAnalysis[]>();

		for (int i = 0; i < numberOfExamples; i++) {
			DungTheory generatedFramework = this.generateFramework(abortFrameworkNotComply);
			if(generatedFramework != null)
			{
				ArrayList<ContainerTransitionStateAnalysis> analysesForDiffSemantics = new ArrayList<ContainerTransitionStateAnalysis>();

				for (int j = 0; j < semanticsForSerializing.length; j++) {
					ContainerTransitionStateAnalysis analysis = deriveAnalysis(semanticsForSerializing[j], generatedFramework, abortAnalysisNotComply);
					 if(analysis != null)analysesForDiffSemantics.add(analysis);
				}
				
				if(analysesForDiffSemantics.isEmpty() == false)
					results.put(generatedFramework, analysesForDiffSemantics.toArray(new ContainerTransitionStateAnalysis[0]));
			}
		}
		return results;
	}

	/**
	 * Creates exemplary argumentation frameworks and analyzes their serialisable extensions.
	 * The method generates frameworks starting with the specified number of arguments,
	 * and increasing this number by the specified increment
	 * as long as the number stays lower or equal than the specified maximum number of arguments (inclusive boundary).
	 * Creates for each framework generated one analysis per specified semantics.
	 * @param semanticsForSerializing Semantics of the extensions created during the serializing process, which will be analyzed.
	 * @param numberOfArgumentsStart Number of Arguments of the first framework, which will be generated as an example.
	 * @param maxNumberOfArguments Maximum number of arguments of any framework generated by this method.
	 * @param numberOfExamplesPerIncrement Number of examples created with the same number of arguments.
	 * @param incrementForNumberOfArguments Increment by which the number of arguments is increased each time.
	 * @param abortFrameworkNotComply If TRUE, an exception is thrown and the method aborted whenever no framework compliant to the conditions can be generated. If FALSE, skips settings for non compliant frameworks and returns less output.
	 * @param abortAnalysisNotComply If TRUE, an exception is thrown and the method aborted whenever an analysis doesn't comply the conditions. If FALSE, skips non compliant analysis and returns less output.
	 * @return Frameworks mapped to the associated analyses using different semantics
	 * @throws ExceptionNotSatisfiedPostulate Throws an exception, if no framework compliant to the conditions could be created within the specified number of maximum attempts
	 */
	public  LinkedHashMap<DungTheory, ContainerTransitionStateAnalysis[]> findExampleForDifferentSemantics(
			Semantics[] semanticsForSerializing,
			int numberOfArgumentsStart,
			int maxNumberOfArguments,
			int numberOfExamplesPerIncrement,
			int incrementForNumberOfArguments,
			boolean abortFrameworkNotComply, 
			boolean abortAnalysisNotComply) throws ExceptionNotSatisfiedPostulate
	{
		LinkedHashMap<DungTheory, ContainerTransitionStateAnalysis[]> output = new LinkedHashMap<DungTheory, ContainerTransitionStateAnalysis[]>();

		for (int i = numberOfArgumentsStart; i <= maxNumberOfArguments; i += incrementForNumberOfArguments) {
			this.changeParameterNumberOfArguments(i);
			output.putAll(this.findExampleForDifferentSemantics(semanticsForSerializing, numberOfExamplesPerIncrement, abortFrameworkNotComply, abortAnalysisNotComply));
		}

		return output;
	}

	/**
	 * Generates a framework, which complies to the specified conditions
	 * @throws ExceptionNotSatisfiedPostulate Throws an exception, if the generated frameworks couldn't satisfy the condition within the specified number of allowed attempts
	 */
	private DungTheory generateFramework(boolean abortFrameworkNotComply) throws ExceptionNotSatisfiedPostulate {
		DungTheory generatedFramework;

		boolean mustRepeat = false;
		int numTryLeft = this.maxNumberTryGenerateFramework;
		do {
			if(numTryLeft == 0) {
				if(abortFrameworkNotComply)throw new ExceptionNotSatisfiedPostulate();
				else return null;
			}
			generatedFramework = this.generator.next();


			for (Principle condition : this.conditionsFramework.keySet()) {
				boolean conditionSatisfied = condition.isSatisfied(generatedFramework, this.conditionsFramework.get(condition));
				if(!conditionSatisfied) {
					mustRepeat = true;
				}
			}
			numTryLeft--;
		} while (mustRepeat);
		return generatedFramework;
	}
	
	/**
	 * 
	 * @param semanticsForSerializing Semantics used to serialize the extensions
	 * @param framework Argumentation framework, in which the extension will be searched
	 * @return Analysis of the serialisable extensions.
	 * @throws ExceptionNotSatisfiedPostulate Throws the exception if the derived analysis, couldn't satisfy the condition
	 */
	private ContainerTransitionStateAnalysis deriveAnalysis(
			Semantics semanticsForSerializing,
			DungTheory framework,
			boolean abortAnalysisNotComply) throws ExceptionNotSatisfiedPostulate {
		
		ContainerTransitionStateAnalysis output = SerialisableExtensionReasonerWithAnalysis.
				getSerialisableReasonerForSemantics(semanticsForSerializing).getModelsWithAnalysis(framework);
		
		boolean analysisAccepted = true;
		for (Postulate<Argument> condition : this.conditionsAnalysis.keySet()) {
			//boolean conditionIsSatisfied = condition.isSatisfied(output.getGraphResulting().getNodes(), this.conditionsAnalysis.get(condition));
			//if(conditionIsSatisfied == false) analysisAccepted = false;
		}
		if(analysisAccepted == false) {
			if(abortAnalysisNotComply)throw new ExceptionNotSatisfiedPostulate();
			else return null;
		}
		
		return output;
	}
}
