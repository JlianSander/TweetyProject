/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. ASPCore2Parser.jj */
/*@egen*//*
 *  This file is part of "Tweety", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  Tweety is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2018 The Tweety Project Team <http://tweetyproject.org/contact/>
 */

options {
             
               
                         
  STATIC=false;
}

PARSER_BEGIN(ASPCore2Parser)

package net.sf.tweety.lp.asp.parser;
import java.io.*;
import net.sf.tweety.lp.asp.syntax.*;
import net.sf.tweety.lp.asp.semantics.*;

/**
 * 
 * Parser for ASP programs in the ASP-Core-2 syntax 
 * <a href="https://www.mat.unical.it/aspcomp2013/files/ASP-CORE-2.03c.pdf">https://www.mat.unical.it/aspcomp2013/files/ASP-CORE-2.03c.pdf</a>.
 * This parser also supports most of the (<a href=" https://potassco.org/clingo/">Clingo</a>) 
 * and <a href="http://www.dlvsystem.com/html/DLV_User_Manual.html">DLV</a>
 * input syntaxes and provides additional methods for parsing answer sets given by the DLV and Clingo solvers.
 *
 * <br>
 * <br>
 * The EBNF grammar for ASP-Core-2 is given as follows: <br>
 * PROGRAM ::== (STATEMENT)* (QUERY)? <br>
 * QUERY ::== LITERAL "?" <br>
 * STATEMENT ::== ":-" BODY_ELEMENTS "." | HEAD (":-" BODY_ELEMENTS)? "." | ":~"
 * BODY_ELEMENTS "." | OPTIMIZE "." <br>
 * HEAD ::== (LITERAL "|")* LITERAL | CHOICE <br>
 * BODY_ELEMENTS ::== (BODY_ELEMENTS ",")? BODY_ELEMENT <br>
 * BODY_ELEMENT ::== NAF_LITERAL | ("not")? AGGREGATE <br>
 * CHOICE ::== (TERM BINOP)? "{" CHOICE_ELEMENTS "}" (BINOP TERM)? <br>
 * CHOICE_ELEMENTS ::== (CHOICE_ELEMENTS ";")? CHOICE_ELEMENT <br>
 * CHOICE_ELEMENT ::== LITERAL (":" NAF_LITERALS)? <br>
 * AGGREGATE ::== (TERM BINOP)? AGGREGATE_FUNCTION "{" AGGREGATE_ELEMENTS "}"
 * (BINOP TERM)? <br>
 * AGGREGATE_ELEMENTS ::== (AGGREGATE_ELEMENTS ";")? AGGREGATE_ELEMENT <br>
 * AGGREGATE_ELEMENT ::== (Terms)? (":" NAF_LITERALS)? <br>
 * AGGREGATE_FUNCTION ::== "#max" | "#min" | "#count" | "#sum" <br>
 * OPTIMIZE ::== OPTIMIZE_FUNCTION "{" (OPTIMIZE_ELEMENTS)? "}" <br>
 * OPTIMIZE_ELEMENTS ::== (OPTIMIZE_ELEMENTS ";")? OPTIMIZE_ELEMENT <br>
 * OPTIMIZE_ELEMENT ::== WEIGHT_AT_LEVEL (":" NAF_LITERALS)? <br>
 * OPTIMIZE_FUNCTION ::== "#maximize" | "#maximise" | "#minimize"| "#minimise"
 * <br>
 * WEIGHT_AT_LEVEL ::== TERM ("@" TERM)? ("," TERMS)? <br>
 * NAF_LITERALS ::== (NAF_LITERALS ",")? NAF_LITERAL <br>
 * NAF_LITERAL ::== ("not")? LITERAL | BUILTIN_ATOM <br>
 * LITERAL ::== ("-")? ID ("(" Terms ")")? <br>
 * BUILTIN_ATOM ::== TERM BINOP TERM <br>
 * BINOP ::== "=" | "!=" | "<>" | "<" | ">" | "<=" | ">=" <br>
 * TERMS ::== (TERMS ",")? TERM <br>
 * TERM ::== ID ("(" TERMS ")")? | NUMBER | STRING | VARIABLE | "_" | "(" TERM
 * ")" | "-" TERM | TERM ARITHOP TERM <br>
 * ARITHOP ::== "+" | "-" | "*" | "/" <br>
 * 
 * where ID is a sequence of letters, numbers, and "_" that starts with a
 * lowercase letter, VARIABLE is a sequence of letters, numbers, and "_" that
 * starts with an uppercase letter, STRING is a sequence of arbitrary characters
 * surrounded by quotation marks ("...") and NUMBER is a sequence of numbers.
 * <br>
 * <br> The following 
 * constructs from Clingo are supported additionally to the ASP-Core-2 syntax:
 * <br> - show statements : "#show " ID "/" NUMBER 
 * <br> Other Clingo meta-statements (#include, #external, #program, #script and #const)
 * are currently not supported.
 * <br>
 * <br>The following constructs from DLV are supported additionally to the ASP-Core-2 syntax:
 * <br> -  TODO
 * @author Anna Gessler
 * 
 */
public class ASPCore2Parser/*@bgen(jjtree)*/implements ASPCore2ParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTASPCore2ParserState jjtree = new JJTASPCore2ParserState();

/*@egen*/
 private static ASPCore2Parser oneThreadParser = new ASPCore2Parser(new StringReader(""));

 private static InstantiateVisitor visitor = new InstantiateVisitor();

 public static Program parseProgram(String program) throws ParseException
  {
    return parseProgram(new StringReader(program));
  }
  
 public static Program parseProgram(Reader reader) throws ParseException
  {
    oneThreadParser.ReInit(reader);
    return visitor.visit(oneThreadParser.Program(), null);
  }
  
   public static ASPRule parseRule(String rule) throws ParseException
  {
    return parseRule(new StringReader(rule));
  }
  
 public static ASPRule parseRule(Reader reader) throws ParseException
  {
    oneThreadParser.ReInit(reader);
    return visitor.visit(oneThreadParser.Statement(), null);
  }
  
    public static AnswerSet parseAnswerSet(String answerSet) throws ParseException
  {
    return parseAnswerSet(new StringReader(answerSet));
  }

  public static AnswerSet parseAnswerSet(Reader reader) throws ParseException
  {
    oneThreadParser.ReInit(reader);
    return visitor.visit(oneThreadParser.AnswerSet(), null);
  }
}
  
PARSER_END(ASPCore2Parser)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| <COMMENT: "%" (~["\n"])* "\n">
| <MULTI_LINE_COMMENT: "%*" (~["%"])* "*%">
}

TOKEN :
{
   <NAF:                 "not">
|  <ID:                  ["a"-"z"] ( ["A"-"Z", "a"-"z", "0"-"9","_"] )* >
|  <VARIABLE:            ["A"-"Z"] ( ["A"-"Z", "a"-"z", "0"-"9","_"] )* >
|  <STRING:              "\"" ( (~["\\", "\""]) | "\\\"" )* "\"" >
|  <NUMBER:              "0" | ["1"-"9"](["0"-"9"])* >
|  <ANONYMOUS_VARIABLE:  "_">
|  <DOT:                 ".">
|  <COMMA:               ",">
|  <QUERY_MARK:          "?">
|  <COLON:               ":">
|  <SEMICOLON:           ";">
|  <OR:                  "|">
|  <CONS:                ":-">
|  <WCONS:               ":~">
|  <PLUS:                "+">
|  <MINUS:               "-">
|  <TIMES:               "*">
|  <DIV:                 "/">
|  <AT:                  "@">
|  <PAREN_OPEN:          "(">
|  <PAREN_CLOSE:         ")">
|  <SQUARE_OPEN:         "[">
|  <SQUARE_CLOSE:        "]">
|  <CURLY_OPEN:          "{">
|  <CURLY_CLOSE:         "}">
|  <EQUAL:               "=" | "==">
|  <UNEQUAL:             "<>" | "!=">
|  <LESS:                "<">
|  <GREATER:             ">">
|  <LESS_OR_EQ:          "<=">
|  <GREATER_OR_EQ:       ">=">
|  <AGGREGATE_COUNT:     "#count">
|  <MINIMIZE:            "#minimi[zs]e">
|  <MAXIMIZE:            "#maximi[zs]e">
|  <AGGREGATE_MAX:       "#max">
|  <AGGREGATE_MIN:       "#min">
|  <AGGREGATE_SUM:       "#sum">
|  <CLINGO_SHOW: 	     "#show " (["a"-"z"] ( ["A"-"Z", "a"-"z", "0"-"9","_"] )*) "/" ("0" | ["1"-"9"](["0"-"9"])* ".")>
}

ASTAnswerSet AnswerSet()           :
{/*@bgen(jjtree) AnswerSet */
  ASTAnswerSet jjtn000 = new ASTAnswerSet(JJTANSWERSET);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
  {/*@bgen(jjtree) AnswerSet */
     try {
/*@egen*/
     (
     (ClassicalLiteral())* 
     )/*@bgen(jjtree)*/
     {
       jjtree.closeNodeScope(jjtn000, true);
       jjtc000 = false;
     }
/*@egen*/
     { return jjtn000; }/*@bgen(jjtree)*/
     } catch (Throwable jjte000) {
       if (jjtc000) {
         jjtree.clearNodeScope(jjtn000);
         jjtc000 = false;
       } else {
         jjtree.popNode();
       }
       if (jjte000 instanceof RuntimeException) {
         throw (RuntimeException)jjte000;
       }
       if (jjte000 instanceof ParseException) {
         throw (ParseException)jjte000;
       }
       throw (Error)jjte000;
     } finally {
       if (jjtc000) {
         jjtree.closeNodeScope(jjtn000, true);
       }
     }
/*@egen*/
  }
  
ASTProgram Program()         :
{/*@bgen(jjtree) Program */
  ASTProgram jjtn000 = new ASTProgram(JJTPROGRAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
  {/*@bgen(jjtree) Program */
     try {
/*@egen*/
     ([LOOKAHEAD(<CONS> | <WCONS> | Head() | Optimize() <DOT> | <CLINGO_SHOW>) Statements()] 
     [Query()]
     <EOF>)/*@bgen(jjtree)*/
     {
       jjtree.closeNodeScope(jjtn000, true);
       jjtc000 = false;
     }
/*@egen*/
     { return jjtn000; }/*@bgen(jjtree)*/
     } catch (Throwable jjte000) {
       if (jjtc000) {
         jjtree.clearNodeScope(jjtn000);
         jjtc000 = false;
       } else {
         jjtree.popNode();
       }
       if (jjte000 instanceof RuntimeException) {
         throw (RuntimeException)jjte000;
       }
       if (jjte000 instanceof ParseException) {
         throw (ParseException)jjte000;
       }
       throw (Error)jjte000;
     } finally {
       if (jjtc000) {
         jjtree.closeNodeScope(jjtn000, true);
       }
     }
/*@egen*/
  }

ASTRuleList Statements()          :
{/*@bgen(jjtree) RuleList */
  ASTRuleList jjtn000 = new ASTRuleList(JJTRULELIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) RuleList */
  try {
/*@egen*/
  (LOOKAHEAD(Statement()) Statement())+/*@bgen(jjtree)*/
   {
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
   }
/*@egen*/ 
   { return jjtn000; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

ASTQuery Query()       :
{/*@bgen(jjtree) Query */
  ASTQuery jjtn000 = new ASTQuery(JJTQUERY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Query */
  try {
/*@egen*/
  ( ClassicalLiteral() <QUERY_MARK> )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { return jjtn000; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

ASTRule Statement()      :
{/*@bgen(jjtree) Rule */
  ASTRule jjtn000 = new ASTRule(JJTRULE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Rule */
  try {
/*@egen*/
  (
  (ClingoMetaStatement())
  | (<CONS> [Body()] <DOT>)
  | (Head() [<CONS> [Body()]] <DOT>)
  | (<WCONS> [Body()] <DOT> <SQUARE_OPEN> WeightAtLevel() <SQUARE_CLOSE>)
  | (Optimize() <DOT>)
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  
  { return jjtn000; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

ASTHead Head()      :
{/*@bgen(jjtree) Head */
  ASTHead jjtn000 = new ASTHead(JJTHEAD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Head */
  try {
/*@egen*/
  (
  LOOKAHEAD([Term() Binop()] <CURLY_OPEN>) (Choice())
  | (Disjunction())
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  
  { return jjtn000; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

ASTBodyList Body()          :
{/*@bgen(jjtree) BodyList */
  ASTBodyList jjtn000 = new ASTBodyList(JJTBODYLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) BodyList */
  try {
/*@egen*/
  (
  (LOOKAHEAD(Body1() <COMMA>) Body1() <COMMA>)* Body1()
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { return jjtn000; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

ASTBody Body1()      : {/*@bgen(jjtree) Body */
  ASTBody jjtn000 = new ASTBody(JJTBODY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Body */
  try {
/*@egen*/
  (
  LOOKAHEAD([<NAF>] [Term() Binop()] AggregateFunction()) [<NAF>] Aggregate()
  | NAFLiteral()
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  
  { return jjtn000; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

ASTHeadElementsList Disjunction()                  :
{/*@bgen(jjtree) HeadElementsList */
  ASTHeadElementsList jjtn000 = new ASTHeadElementsList(JJTHEADELEMENTSLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) HeadElementsList */
  try {
/*@egen*/
  (
  (LOOKAHEAD(ClassicalLiteral() <OR>) ClassicalLiteral() <OR>)* ClassicalLiteral()
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { return jjtn000; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

ASTChoice Choice()        :
{/*@bgen(jjtree) Choice */
  ASTChoice jjtn000 = new ASTChoice(JJTCHOICE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Choice */
  try {
/*@egen*/
  (
  [Term() Binop()] <CURLY_OPEN> [ChoiceElements()] <CURLY_CLOSE> [Binop() Term()]
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { return jjtn000; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

ASTChoiceElementList ChoiceElements()                   :
{/*@bgen(jjtree) ChoiceElementList */
  ASTChoiceElementList jjtn000 = new ASTChoiceElementList(JJTCHOICEELEMENTLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ChoiceElementList */
  try {
/*@egen*/
  (
  (LOOKAHEAD(ChoiceElement() <SEMICOLON>) ChoiceElement() <SEMICOLON>)* ChoiceElement()
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { return jjtn000; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

ASTChoiceElement ChoiceElement()               :
{/*@bgen(jjtree) ChoiceElement */
  ASTChoiceElement jjtn000 = new ASTChoiceElement(JJTCHOICEELEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ChoiceElement */
  try {
/*@egen*/
  ( ClassicalLiteral() [<COLON> [NAFLiterals()]] )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { return jjtn000; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

ASTAggregate Aggregate()           :
{/*@bgen(jjtree) Aggregate */
  ASTAggregate jjtn000 = new ASTAggregate(JJTAGGREGATE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Aggregate */
  try {
/*@egen*/
  (
  [Term() Binop()] AggregateFunction() <CURLY_OPEN> AggregateElements()
  <CURLY_CLOSE> [Binop() Term()]
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { return jjtn000; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

ASTAggrElementList AggregateElements()                 :
{/*@bgen(jjtree) AggrElementList */
  ASTAggrElementList jjtn000 = new ASTAggrElementList(JJTAGGRELEMENTLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AggrElementList */
  try {
/*@egen*/
  (
  (LOOKAHEAD(AggregateElement() <SEMICOLON>) AggregateElement() <SEMICOLON>)* AggregateElement()
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { return jjtn000; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

ASTAggrElement AggregateElement()             :
{/*@bgen(jjtree) AggrElement */
  ASTAggrElement jjtn000 = new ASTAggrElement(JJTAGGRELEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AggrElement */
  try {
/*@egen*/
  (
  [Terms()] [<COLON> [NAFLiterals()]]
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { return jjtn000; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

String AggregateFunction()          :
{/*@bgen(jjtree) AggrFunc */
  ASTAggrFunc jjtn000 = new ASTAggrFunc(JJTAGGRFUNC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AggrFunc */
  try {
/*@egen*/
  ( <AGGREGATE_COUNT>
  | <AGGREGATE_MAX>
  | <AGGREGATE_MIN>
  | <AGGREGATE_SUM> )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
 
  { 
  	jjtn000.func(this.token.image);
  	return this.token.image; }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void ClingoMetaStatement()            :
{/*@bgen(jjtree) ClingoMeta */
 ASTClingoMeta jjtn000 = new ASTClingoMeta(JJTCLINGOMETA);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) ClingoMeta */
  try {
/*@egen*/
  ( t=<CLINGO_SHOW> )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { 
  	 jjtn000.statement(t.image); }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

ASTOpt Optimize()     :
{/*@bgen(jjtree) Opt */
  ASTOpt jjtn000 = new ASTOpt(JJTOPT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Opt */
  try {
/*@egen*/
  (
  OptimizeFunction() <CURLY_OPEN> [OptimizeElements()] <CURLY_CLOSE>
  )/*@bgen(jjtree)*/
   {
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
   }
/*@egen*/
   { return jjtn000; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

ASTOptElementList OptimizeElements()                 :
{/*@bgen(jjtree) OptElementList */
  ASTOptElementList jjtn000 = new ASTOptElementList(JJTOPTELEMENTLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) OptElementList */
  try {
/*@egen*/
  (
  (LOOKAHEAD(OptimizeElement() <SEMICOLON>) OptimizeElement() <SEMICOLON>)* OptimizeElement() 
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { return jjtn000; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

ASTOptElement OptimizeElement()            :
{/*@bgen(jjtree) OptElement */
  ASTOptElement jjtn000 = new ASTOptElement(JJTOPTELEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) OptElement */
  try {
/*@egen*/
  (WeightAtLevel() [<COLON> [NAFLiterals()]])/*@bgen(jjtree)*/
   {
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
   }
/*@egen*/
   { return jjtn000; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

String OptimizeFunction()         :
{/*@bgen(jjtree) OptFunc */
  ASTOptFunc jjtn000 = new ASTOptFunc(JJTOPTFUNC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) OptFunc */
  try {
/*@egen*/
  ( (<MAXIMIZE> {jjtn000.maximize(true);}) | (<MINIMIZE>) )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  
  { 
  	jjtn000.func(this.token.image);
  	return this.token.image; }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

ASTWeight WeightAtLevel()        :
{/*@bgen(jjtree) Weight */
  ASTWeight jjtn000 = new ASTWeight(JJTWEIGHT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Weight */
   try {
/*@egen*/
   ( Term() [<AT> Term() {jjtn000.hasLevel(true);}] [<COMMA> Terms()] )/*@bgen(jjtree)*/
   {
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
   }
/*@egen*/
   { return jjtn000; }/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

ASTNAFLiteralList NAFLiterals()                :
{/*@bgen(jjtree) NAFLiteralList */
  ASTNAFLiteralList jjtn000 = new ASTNAFLiteralList(JJTNAFLITERALLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) NAFLiteralList */
  try {
/*@egen*/
  (
  (LOOKAHEAD(NAFLiteral() <COMMA>) NAFLiteral() <COMMA>)* NAFLiteral()
  )/*@bgen(jjtree)*/
   {
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
   }
/*@egen*/
  
   { return jjtn000; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

ASTNAFLiteral NAFLiteral()            :
{/*@bgen(jjtree) NAFLiteral */
  ASTNAFLiteral jjtn000 = new ASTNAFLiteral(JJTNAFLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) NAFLiteral */
 try {
/*@egen*/
 ( 
 LOOKAHEAD((Term() Binop() Term()) | (Binop())) BuiltinAtom()
 | [<NAF>{jjtn000.nafneg(true);}] ClassicalLiteral()
 )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
 
  { return jjtn000; }/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}
ASTLiteral ClassicalLiteral()         :
{/*@bgen(jjtree) Literal */
  ASTLiteral jjtn000 = new ASTLiteral(JJTLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Literal */
  try {
/*@egen*/
  ( 
  [(<MINUS>{jjtn000.neg(true);})] Identifier() [<PAREN_OPEN> [Terms()] <PAREN_CLOSE>] 
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { return jjtn000; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

ASTBuiltInAtom BuiltinAtom()              :
{/*@bgen(jjtree) BuiltInAtom */
  ASTBuiltInAtom jjtn000 = new ASTBuiltInAtom(JJTBUILTINATOM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) BuiltInAtom */
  try {
/*@egen*/
  (
  (Term() Binop() Term())
  | (Binop() <PAREN_OPEN> Term() <COMMA> Term() <PAREN_CLOSE>)
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { return jjtn000; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

String Binop()       :
{/*@bgen(jjtree) Binop */
  ASTBinop jjtn000 = new ASTBinop(JJTBINOP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Binop */
  try {
/*@egen*/
  (
  <EQUAL>
  | <UNEQUAL>
  | <LESS>
  | <GREATER>
  | <LESS_OR_EQ>
  | <GREATER_OR_EQ>
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { 
  	jjtn000.op(this.token.image);
  	return this.token.image; }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

ASTTermList Terms()          :
{/*@bgen(jjtree) TermList */
  ASTTermList jjtn000 = new ASTTermList(JJTTERMLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TermList */
  try {
/*@egen*/
  (
  (LOOKAHEAD(Term() <COMMA>) Term() <COMMA>)* Term()
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { return jjtn000; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

ASTTerm Term()      :
{/*@bgen(jjtree) Term */
  ASTTerm jjtn000 = new ASTTerm(JJTTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) Term */
  try {
/*@egen*/
  ( (Identifier() [<PAREN_OPEN> [Terms()] <PAREN_CLOSE>] AriTerm() )
  | (Number() AriTerm())
  | (String() AriTerm())
  | (Variable() AriTerm())
  | (<PAREN_OPEN> Term() <PAREN_CLOSE> AriTerm())
  | ((<MINUS>{jjtn000.neg(true);}) Term() AriTerm())  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  
  { return jjtn000; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

ASTAriTerm AriTerm()          : 
{/*@bgen(jjtree) AriTerm */
  ASTAriTerm jjtn000 = new ASTAriTerm(JJTARITERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ String t = "";}
{/*@bgen(jjtree) AriTerm */
  try {
/*@egen*/
  ([LOOKAHEAD(2)(t =Arithop()) Term()])/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { 
  jjtn000.op(t);
  return jjtn000; 
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

String Arithop()         :
{/*@bgen(jjtree) Arithop */
  ASTArithop jjtn000 = new ASTArithop(JJTARITHOP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Arithop */
  try {
/*@egen*/
  (
  <PLUS>
  | <MINUS>
  | <TIMES>
  | <DIV>
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { 
  	return this.token.image; }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Number()         :
{/*@bgen(jjtree) Number */
        ASTNumber jjtn000 = new ASTNumber(JJTNUMBER);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/ 
	Token t;
}
{/*@bgen(jjtree) Number */
        try {
/*@egen*/
	(t=<NUMBER>)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ jjtn000.number(t.image); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Variable()      :
{/*@bgen(jjtree) Var */
  ASTVar jjtn000 = new ASTVar(JJTVAR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) Var */
 try {
/*@egen*/
 (t=<VARIABLE> | t=<ANONYMOUS_VARIABLE>)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
 	{
		jjtn000.name(t.image);
	}/*@bgen(jjtree)*/
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

void Identifier()     : 
{/*@bgen(jjtree) ID */
        ASTID jjtn000 = new ASTID(JJTID);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token t;
} 
{/*@bgen(jjtree) ID */
        try {
/*@egen*/
	(t=<ID>)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.name(t.image);
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void String()         : 
{/*@bgen(jjtree) String */
        ASTString jjtn000 = new ASTString(JJTSTRING);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token t;
} 
{/*@bgen(jjtree) String */
        try {
/*@egen*/
	(t= <STRING>)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.name(t.image);
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
