/*
 *  This file is part of "Tweety", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  Tweety is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2018 The Tweety Project Team <http://tweetyproject.org/contact/>
 */

options {
  MULTI=true;
  VISITOR=true;
  NODE_DEFAULT_VOID=true;
  STATIC=false;
}

PARSER_BEGIN(ASPCore2Parser)

package net.sf.tweety.lp.asp.parser;
import java.io.*;
import net.sf.tweety.lp.asp.syntax.*;
import net.sf.tweety.lp.asp.semantics.*;

/**
 * 
 * Parser for ASP programs in the ASP-Core-2 syntax 
 * <a href="https://www.mat.unical.it/aspcomp2013/files/ASP-CORE-2.03c.pdf">https://www.mat.unical.it/aspcomp2013/files/ASP-CORE-2.03c.pdf</a>.
 * This parser also supports most of the (<a href=" https://potassco.org/clingo/">Clingo</a>) 
 * and <a href="http://www.dlvsystem.com/html/DLV_User_Manual.html">DLV</a>
 * input syntaxes and provides additional methods for parsing answer sets given by the DLV and Clingo solvers.
 *
 * <br>
 * <br>
 * The EBNF grammar for ASP-Core-2 is given as follows: <br>
 * PROGRAM ::== (STATEMENT)* (QUERY)? <br>
 * QUERY ::== LITERAL "?" <br>
 * STATEMENT ::== ":-" BODY_ELEMENTS "." | HEAD (":-" BODY_ELEMENTS)? "." | ":~"
 * BODY_ELEMENTS "." | OPTIMIZE "." <br>
 * HEAD ::== (LITERAL "|")* LITERAL | CHOICE <br>
 * BODY_ELEMENTS ::== (BODY_ELEMENTS ",")? BODY_ELEMENT <br>
 * BODY_ELEMENT ::== NAF_LITERAL | ("not")? AGGREGATE <br>
 * CHOICE ::== (TERM BINOP)? "{" CHOICE_ELEMENTS "}" (BINOP TERM)? <br>
 * CHOICE_ELEMENTS ::== (CHOICE_ELEMENTS ";")? CHOICE_ELEMENT <br>
 * CHOICE_ELEMENT ::== LITERAL (":" NAF_LITERALS)? <br>
 * AGGREGATE ::== (TERM BINOP)? AGGREGATE_FUNCTION "{" AGGREGATE_ELEMENTS "}"
 * (BINOP TERM)? <br>
 * AGGREGATE_ELEMENTS ::== (AGGREGATE_ELEMENTS ";")? AGGREGATE_ELEMENT <br>
 * AGGREGATE_ELEMENT ::== (Terms)? (":" NAF_LITERALS)? <br>
 * AGGREGATE_FUNCTION ::== "#max" | "#min" | "#count" | "#sum" <br>
 * OPTIMIZE ::== OPTIMIZE_FUNCTION "{" (OPTIMIZE_ELEMENTS)? "}" <br>
 * OPTIMIZE_ELEMENTS ::== (OPTIMIZE_ELEMENTS ";")? OPTIMIZE_ELEMENT <br>
 * OPTIMIZE_ELEMENT ::== WEIGHT_AT_LEVEL (":" NAF_LITERALS)? <br>
 * OPTIMIZE_FUNCTION ::== "#maximize" | "#maximise" | "#minimize"| "#minimise"
 * <br>
 * WEIGHT_AT_LEVEL ::== TERM ("@" TERM)? ("," TERMS)? <br>
 * NAF_LITERALS ::== (NAF_LITERALS ",")? NAF_LITERAL <br>
 * NAF_LITERAL ::== ("not")? LITERAL | BUILTIN_ATOM <br>
 * LITERAL ::== ("-")? ID ("(" Terms ")")? <br>
 * BUILTIN_ATOM ::== TERM BINOP TERM <br>
 * BINOP ::== "=" | "!=" | "<>" | "<" | ">" | "<=" | ">=" <br>
 * TERMS ::== (TERMS ",")? TERM <br>
 * TERM ::== ID ("(" TERMS ")")? | NUMBER | STRING | VARIABLE | "_" | "(" TERM
 * ")" | "-" TERM | TERM ARITHOP TERM <br>
 * ARITHOP ::== "+" | "-" | "*" | "/" <br>
 * 
 * where ID is a sequence of letters, numbers, and "_" that starts with a
 * lowercase letter, VARIABLE is a sequence of letters, numbers, and "_" that
 * starts with an uppercase letter, STRING is a sequence of arbitrary characters
 * surrounded by quotation marks ("...") and NUMBER is a sequence of numbers. <br>
 * Single-line comments (starting with "%") and multi-line-comments (starting with "%*", ending with "*%") are ignored by the parser.
 * <br>
 * <br> The following 
 * constructs from Clingo are supported additionally to the ASP-Core-2 syntax:
 * <br> - show statements: "#show " ID "/" NUMBER 
 * <br> Other Clingo meta-statements (#include, #external, #program, #script and #const)
 * are currently not supported.
 * <br>
 * <br>The following constructs from DLV are supported additionally to the ASP-Core-2 syntax:
 * <br> -  TODO
 * @author Anna Gessler
 * 
 */
public class ASPCore2Parser {
 private static ASPCore2Parser oneThreadParser = new ASPCore2Parser(new StringReader(""));

 private static InstantiateVisitor visitor = new InstantiateVisitor();

 public static Program parseProgram(String program) throws ParseException
  {
    return parseProgram(new StringReader(program));
  }
  
 public static Program parseProgram(Reader reader) throws ParseException
  {
    oneThreadParser.ReInit(reader);
    return visitor.visit(oneThreadParser.Program(), null);
  }
  
   public static ASPRule parseRule(String rule) throws ParseException
  {
    return parseRule(new StringReader(rule));
  }
  
 public static ASPRule parseRule(Reader reader) throws ParseException
  {
    oneThreadParser.ReInit(reader);
    return visitor.visit(oneThreadParser.Statement(), null);
  }
  
    public static AnswerSet parseAnswerSet(String answerSet) throws ParseException
  {
    return parseAnswerSet(new StringReader(answerSet));
  }

  public static AnswerSet parseAnswerSet(Reader reader) throws ParseException
  {
    oneThreadParser.ReInit(reader);
    return visitor.visit(oneThreadParser.AnswerSet(), null);
  }
}
  
PARSER_END(ASPCore2Parser)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| <COMMENT: "%" (~["\n"])* "\n">
| <MULTI_LINE_COMMENT: "%*" (~["%"])* "*%">
}

TOKEN :
{
   <NAF:                 "not">
|  <ID:                  ["a"-"z"] ( ["A"-"Z", "a"-"z", "0"-"9","_"] )* >
|  <VARIABLE:            ["A"-"Z"] ( ["A"-"Z", "a"-"z", "0"-"9","_"] )* >
|  <STRING:              "\"" ( (~["\\", "\""]) | "\\\"" )* "\"" >
|  <NUMBER:              "0" | ["1"-"9"](["0"-"9"])* >
|  <ANONYMOUS_VARIABLE:  "_">
|  <DOT:                 ".">
|  <COMMA:               ",">
|  <QUERY_MARK:          "?">
|  <COLON:               ":">
|  <SEMICOLON:           ";">
|  <OR:                  "|">
|  <CONS:                ":-">
|  <WCONS:               ":~">
|  <PLUS:                "+">
|  <MINUS:               "-">
|  <TIMES:               "*">
|  <DIV:                 "/">
|  <AT:                  "@">
|  <PAREN_OPEN:          "(">
|  <PAREN_CLOSE:         ")">
|  <SQUARE_OPEN:         "[">
|  <SQUARE_CLOSE:        "]">
|  <CURLY_OPEN:          "{">
|  <CURLY_CLOSE:         "}">
|  <EQUAL:               "=" | "==">
|  <UNEQUAL:             "<>" | "!=">
|  <LESS:                "<">
|  <GREATER:             ">">
|  <LESS_OR_EQ:          "<=">
|  <GREATER_OR_EQ:       ">=">
|  <AGGREGATE_COUNT:     "#count">
|  <MINIMIZE:            "#minimi[zs]e">
|  <MAXIMIZE:            "#maximi[zs]e">
|  <AGGREGATE_MAX:       "#max">
|  <AGGREGATE_MIN:       "#min">
|  <AGGREGATE_SUM:       "#sum">
|  <CLINGO_SHOW: 	     "#show " (["a"-"z"] ( ["A"-"Z", "a"-"z", "0"-"9","_"] )*) "/" ("0" | ["1"-"9"](["0"-"9"])* ".")>
}

ASTAnswerSet AnswerSet() #AnswerSet:
{}
  {
     (
     (ClassicalLiteral())* 
     )
     { return jjtThis; }
  }
  
ASTProgram Program() #Program:
{}
  {
     ([LOOKAHEAD(<CONS> | <WCONS> | Head() | Optimize() <DOT> | <CLINGO_SHOW>) Statements()] 
     [Query()]
     <EOF>)
     { return jjtThis; }
  }

ASTRuleList Statements() #RuleList:
{}
{
  (LOOKAHEAD(Statement()) Statement())+ 
   { return jjtThis; }
}

ASTQuery Query() #Query:
{}
{
  ( ClassicalLiteral() <QUERY_MARK> )
  { return jjtThis; }
}

ASTRule Statement() #Rule:
{}
{
  (
  (<CONS> [Body()] <DOT>)
  | (Head() [<CONS> [Body()]] <DOT>)
  | (<WCONS> [Body()] <DOT> <SQUARE_OPEN> WeightAtLevel() <SQUARE_CLOSE>)
  | (Optimize() <DOT>)
  | (ClingoMetaStatement())
  )
  
  { return jjtThis; }
}

ASTHead Head() #Head:
{}
{
  (
  LOOKAHEAD([Term() Binop()] <CURLY_OPEN>) (Choice())
  | (Disjunction())
  )
  
  { return jjtThis; }
}

ASTBodyList Body() #BodyList:
{}
{
  (
  (LOOKAHEAD(Body1() <COMMA>) Body1() <COMMA>)* Body1()
  )
  { return jjtThis; }
}

ASTBody Body1() #Body: {}
{
  (
  LOOKAHEAD([<NAF>] [Term() Binop()] AggregateFunction()) [<NAF>] Aggregate()
  | NAFLiteral()
  )
  
  { return jjtThis; }
}

ASTHeadElementsList Disjunction() #HeadElementsList:
{}
{
  (
  (LOOKAHEAD(ClassicalLiteral() <OR>) ClassicalLiteral() <OR>)* ClassicalLiteral()
  )
  { return jjtThis; }
}

ASTChoice Choice() #Choice:
{}
{
  (
  [Term() Binop()] <CURLY_OPEN> [ChoiceElements()] <CURLY_CLOSE> [Binop() Term()]
  )
  { return jjtThis; }
}

ASTChoiceElementList ChoiceElements() #ChoiceElementList:
{}
{
  (
  (LOOKAHEAD(ChoiceElement() <SEMICOLON>) ChoiceElement() <SEMICOLON>)* ChoiceElement()
  )
  { return jjtThis; }
}

ASTChoiceElement ChoiceElement() #ChoiceElement:
{}
{
  ( ClassicalLiteral() [<COLON> [NAFLiterals()]] )
  { return jjtThis; }
}

ASTAggregate Aggregate() #Aggregate:
{}
{
  (
  [Term() Binop()] AggregateFunction() <CURLY_OPEN> AggregateElements()
  <CURLY_CLOSE> [Binop() Term()]
  )
  { return jjtThis; }
}

ASTAggrElementList AggregateElements() #AggrElementList:
{}
{
  (
  (LOOKAHEAD(AggregateElement() <SEMICOLON>) AggregateElement() <SEMICOLON>)* AggregateElement()
  )
  { return jjtThis; }
}

ASTAggrElement AggregateElement() #AggrElement:
{}
{
  (
  [Terms()] [<COLON> [NAFLiterals()]]
  )
  { return jjtThis; }
}

String AggregateFunction() #AggrFunc:
{}
{
  ( <AGGREGATE_COUNT>
  | <AGGREGATE_MAX>
  | <AGGREGATE_MIN>
  | <AGGREGATE_SUM> )
 
  { 
  	jjtThis.func(this.token.image);
  	return this.token.image; }
}

void ClingoMetaStatement() #ClingoMeta:
{Token t;}
{
  ( t=<CLINGO_SHOW> )
  { 
  	 jjtThis.statement(t.image); }
}

ASTOpt Optimize() #Opt:
{}
{
  (
  OptimizeFunction() <CURLY_OPEN> [OptimizeElements()] <CURLY_CLOSE>
  )
   { return jjtThis; }
}

ASTOptElementList OptimizeElements() #OptElementList :
{}
{
  (
  (LOOKAHEAD(OptimizeElement() <SEMICOLON>) OptimizeElement() <SEMICOLON>)* OptimizeElement() 
  )
  { return jjtThis; }
}

ASTOptElement OptimizeElement() #OptElement:
{}
{
  (WeightAtLevel() [<COLON> [NAFLiterals()]])
   { return jjtThis; }
}

String OptimizeFunction() #OptFunc:
{}
{
  ( (<MAXIMIZE> {jjtThis.maximize(true);}) | (<MINIMIZE>) )
  
  { 
  	jjtThis.func(this.token.image);
  	return this.token.image; }
}

ASTWeight WeightAtLevel() #Weight:
{}
{
   ( Term() [<AT> Term() {jjtThis.hasLevel(true);}] [<COMMA> Terms()] )
   { return jjtThis; }
}

ASTNAFLiteralList NAFLiterals() #NAFLiteralList:
{}
{
  (
  (LOOKAHEAD(NAFLiteral() <COMMA>) NAFLiteral() <COMMA>)* NAFLiteral()
  )
  
   { return jjtThis; }
}

ASTNAFLiteral NAFLiteral() #NAFLiteral:
{}
{
 ( 
 LOOKAHEAD((Term() Binop() Term()) | (Binop())) BuiltinAtom()
 | [<NAF>{jjtThis.nafneg(true);}] ClassicalLiteral()
 )
 
  { return jjtThis; }
}
ASTLiteral ClassicalLiteral() #Literal:
{}
{
  ( 
  [(<MINUS>{jjtThis.neg(true);})] Identifier() [<PAREN_OPEN> [Terms()] <PAREN_CLOSE>] 
  )
  { return jjtThis; }
}

ASTBuiltInAtom BuiltinAtom() #BuiltInAtom :
{}
{
  (
  (Term() Binop() Term())
  | (Binop() <PAREN_OPEN> Term() <COMMA> Term() <PAREN_CLOSE>)
  )
  { return jjtThis; }
}

String Binop() #Binop:
{}
{
  (
  <EQUAL>
  | <UNEQUAL>
  | <LESS>
  | <GREATER>
  | <LESS_OR_EQ>
  | <GREATER_OR_EQ>
  )
  { 
  	jjtThis.op(this.token.image);
  	return this.token.image; }
}

ASTTermList Terms() #TermList:
{}
{
  (
  (LOOKAHEAD(Term() <COMMA>) Term() <COMMA>)* Term()
  )
  { return jjtThis; }
}

ASTTerm Term() #Term:
{ Token t; }
{
  ( (Identifier() [<PAREN_OPEN> [Terms()] <PAREN_CLOSE>] AriTerm() )
  | (Number() AriTerm())
  | (String() AriTerm())
  | (Variable() AriTerm())
  | (<PAREN_OPEN> Term() <PAREN_CLOSE> AriTerm())
  | ((<MINUS>{jjtThis.neg(true);}) Term() AriTerm())  )
  
  { return jjtThis; }
}

ASTAriTerm AriTerm() #AriTerm : 
{ String t = "";}
{
  ([LOOKAHEAD(2)(t =Arithop()) Term()])
  { 
  jjtThis.op(t);
  return jjtThis; 
  }
}

String Arithop() #Arithop:
{}
{
  (
  <PLUS>
  | <MINUS>
  | <TIMES>
  | <DIV>
  )
  { 
  	return this.token.image; }
}

void Number() #Number :
{ 
	Token t;
}
{
	(t=<NUMBER>)
	{ jjtThis.number(t.image); }
}

void Variable() #Var :
{ Token t; }
{
 (t=<VARIABLE> | t=<ANONYMOUS_VARIABLE>)
 	{
		jjtThis.name(t.image);
	}
}

void Identifier() #ID : 
{
	Token t;
} 
{
	(t=<ID>)
	{
		jjtThis.name(t.image);
	}
}

void String() #String : 
{
	Token t;
} 
{
	(t= <STRING>)
	{
		jjtThis.name(t.image);
	}
}
