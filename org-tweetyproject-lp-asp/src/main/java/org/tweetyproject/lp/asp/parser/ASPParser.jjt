/*
 *  This file is part of "Tweety", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  Tweety is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2018 The Tweety Project Team <http://tweetyproject.org/contact/>
 */

options {
  MULTI=true;
  VISITOR=true;
  NODE_DEFAULT_VOID=true;
  STATIC=false;
}

PARSER_BEGIN(ASPParser)

package org.tweetyproject.lp.asp.parser;
import java.io.*;
import org.tweetyproject.lp.asp.syntax.*;
import org.tweetyproject.lp.asp.semantics.*;

/**
 * 
 * Parser for ASP programs in the ASP-Core-2 syntax 
 * (<a href="https://www.mat.unical.it/aspcomp2013/files/ASP-CORE-2.03c.pdf">https://www.mat.unical.it/aspcomp2013/files/ASP-CORE-2.03c.pdf</a>).
 * This parser also supports most of the <a href=" https://potassco.org/clingo/">Clingo</a>
 * and <a href="http://www.dlvsystem.com/html/DLV_User_Manual.html">DLV</a>
 * input syntaxes and provides additional methods for parsing answer sets given by the DLV and Clingo solvers.
 * <br>See {@link org.tweetyproject.lp.asp.examples.ASPParserExample} for examples on how to use this parser.
 * <br>
 * <br> Note for developers: This parser is generated by JavaCC. To make changes to the grammar, edit "ASPParser.jjt". Then invoke
 * the JJTree preprocessor by calling "jjtree ASPParser.jjt" on the command line (this generates the .jj file). Then
 * run "javacc ASPParser.jj" to generate the parser (i.e. the ASPParser class and the various AST classes). 
 * In many cases you will also have to edit the {@link org.tweetyproject.lp.asp.parser.InstantiateVisitor}
 * class which defines how the AST nodes are parsed into TweetyProject's syntax classes. 
 * <br> See <a href="https://javacc.github.io/javacc/">https://javacc.github.io/javacc/</a> for more information on JavaCC.
 * <br> 
 * <br>
 * The EBNF grammar for this parser is given as follows: <br>
 * PROGRAM ::== (STATEMENT)* (QUERY)? <br>
 * QUERY ::== LITERAL "?" <br>
 * STATEMENT ::== ":-" BODY_ELEMENTS "." | HEAD (":-" BODY_ELEMENTS)? "." | ":~" | BODY_ELEMENTS "." | OPTIMIZE "." | META <br>
 * HEAD ::== (LITERAL ("|" | "v"))* LITERAL | CHOICE | AGGREGATE <br>
 * BODY_ELEMENTS ::== (BODY_ELEMENTS ",")? BODY_ELEMENT <br>
 * BODY_ELEMENT ::== NAF_LITERAL | ("not")? AGGREGATE <br>
 * CHOICE ::== (TERM BINOP)? "{" CHOICE_ELEMENTS "}" (BINOP TERM)? <br>
 * CHOICE_ELEMENTS ::== (CHOICE_ELEMENTS ";")? CHOICE_ELEMENT <br>
 * CHOICE_ELEMENT ::== LITERAL (":" NAF_LITERALS)? <br>
 * AGGREGATE ::== (TERM BINOP)? AGGREGATE_FUNCTION "{" AGGREGATE_ELEMENTS "}" (BINOP TERM)? <br>
 * AGGREGATE_ELEMENTS ::== (AGGREGATE_ELEMENTS ";")? AGGREGATE_ELEMENT <br>
 * AGGREGATE_ELEMENT ::== (Terms)? (":" NAF_LITERALS)? <br>
 * AGGREGATE_FUNCTION ::== "#max" | "#min" | "#count" | "#sum" | "#sum+" | "#times" <br>
 * OPTIMIZE ::== OPTIMIZE_FUNCTION "{" (OPTIMIZE_ELEMENTS)? "}" <br>
 * OPTIMIZE_ELEMENTS ::== (OPTIMIZE_ELEMENTS ";")? OPTIMIZE_ELEMENT <br>
 * OPTIMIZE_ELEMENT ::== WEIGHT_AT_LEVEL (":" NAF_LITERALS)? <br>
 * OPTIMIZE_FUNCTION ::== "#maximize" | "#maximise" | "#minimize"| "#minimise" <br>
 * META ::== "#show " ID "/" NUMBER | "#maxint" "=" "NUMBER | "#const" ID "=" ID
 * WEIGHT_AT_LEVEL ::== TERM ("@" TERM)? ("," TERMS)? <br>
 * NAF_LITERALS ::== (NAF_LITERALS ",")? NAF_LITERAL <br>
 * NAF_LITERAL ::== ("not")? LITERAL | BUILTIN_ATOM <br>
 * LITERAL ::== ("-")? (ID | DLV_ID) ("(" Terms ")")? <br>
 * BUILTIN_ATOM ::== TERM BINOP TERM | DLV_ARITHMETIC_ID "(" Terms ")" | ARITHOP "(" TERM "," TERM "," TERM ")" <br>
 * BINOP ::== "=" | "!=" | "<>" | "<" | ">" | "<=" | ">=" <br>
 * TERMS ::== (TERMS ",")? TERM <br>
 * TERM ::== ID ("(" TERMS ")")? | NUMBER | STRING | VARIABLE | "_" | "(" TERM
 * ")" | "-" TERM | TERM ARITHOP TERM <br>
 * ARITHOP ::== "+" | "-" | "*" | "/" | "\" <br>
 * DLV_ARITHMETIC_ID ::== "#succ" | "#int" | "#prec" | "#mod" <br>
 * DLV_ID ::== "#rand"|"#int"|"#absdiff"|"#append"|"#delnth"|"#flatten"|"#getnth"|"#head"|"#insLast"|"#insnth"|"#last"|"#length"|"#member"|"#reverse"|"#subList"|"#tail" <br>
 * <br>
 * where ID is a sequence of letters, numbers, and "_" that starts with a
 * lowercase letter, VARIABLE is a sequence of letters, numbers, and "_" that
 * starts with an uppercase letter, STRING is a sequence of arbitrary characters
 * surrounded by quotation marks ("...") and NUMBER is a sequence of numbers. <br>
 * Single-line comments (starting with "%") and multi-line-comments (starting with "%*", ending with "*%") are ignored by the parser.
 * <br>
 * <br> The grammar given above is mostly equivalent to the ASP-Core-2 grammar. The main differences are that some variations in symbols are
 * supported (such as DLV using "v" instead of "|") and that special constructs from Clingo and DLV are allowed:
 * <br> - #show statements (Clingo): The whitelisted atoms are added to the program's outputPredicateWhitelist and can be used by ClingoSolver if enabled
 * with ClingoSolver.toggleOutputWhitelist(true)
 * <br> - #succ, #prec, #mod predicates, +(X,Y,Z), -(X,Y,Z), *(X,Y,Z), /(X,Y,Z) (DLV): They are converted into equivalent built-in atoms (clingo syntax)
 * <br> - #maxint statements: They are used in place of the integerMaximum parameter when calling solvers
 * <br> - #const constants: They are added to the program's additionalOptions and are automatically used by ClingoSolver and DLVSolver
 * <br> - other arithmetic predicates (such as #int) and list predicates (such as #append) from DLV: They are parsed as special predicates 
 * that can only be used with the DLV solver but not with Clingo
 * <br> Other Clingo/DLV meta-statements (such as #include, #external, #program, #script) are ignored.
 * <br>
 *
 * @author Anna Gessler
 * 
 */
public class ASPParser {
 private static ASPParser oneThreadParser = new ASPParser(new StringReader(""));

 private static InstantiateVisitor visitor = new InstantiateVisitor();

 public static Program parseProgram(String program) throws ParseException
  {
    return parseProgram(new StringReader(program));
  }
  
 public static Program parseProgram(Reader reader) throws ParseException
  {
    oneThreadParser.ReInit(reader);
    return visitor.visit(oneThreadParser.Program(), null);
  }
  
   public static ASPRule parseRule(String rule) throws ParseException
  {
    return parseRule(new StringReader(rule));
  }
  
 public static ASPRule parseRule(Reader reader) throws ParseException
  {
    oneThreadParser.ReInit(reader);
    return visitor.visit(oneThreadParser.Statement(), null);
  }
  
    public static AnswerSet parseAnswerSet(String answerSet) throws ParseException
  {
    return parseAnswerSet(new StringReader(answerSet));
  }

  public static AnswerSet parseAnswerSet(Reader reader) throws ParseException
  {
    oneThreadParser.ReInit(reader);
    return visitor.visit(oneThreadParser.AnswerSet(), null);
  }
}
  
PARSER_END(ASPParser)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| <COMMENT: "%" (~["\n"])*>
| <MULTI_LINE_COMMENT: "%*" (~["%"])* "*%">
}

TOKEN :
{
   <NAF:                 "not">
|  <OR:                  "|"|"v">
|  <ID:                  ["a"-"z"] ( ["A"-"Z", "a"-"z", "0"-"9","_"] )* >
|  <VARIABLE:            ["A"-"Z"] ( ["A"-"Z", "a"-"z", "0"-"9","_"] )* >
|  <STRING:              "\"" ( (~["\\", "\""]) | "\\\"" )* "\"" >
|  <NUMBER:              "0" | ["1"-"9"](["0"-"9"])* >
|  <ANONYMOUS_VARIABLE:  "_">
|  <DOT:                 ".">
|  <COMMA:               ",">
|  <QUERY_MARK:          "?">
|  <COLON:               ":">
|  <SEMICOLON:           ";">
|  <CONS:                ":-">
|  <WCONS:               ":~">
|  <PLUS:                "+">
|  <MINUS:               "-">
|  <TIMES:               "*">
|  <DIV:                 "/">
|  <MODULO:				 "\\">
|  <AT:                  "@">
|  <PAREN_OPEN:          "(">
|  <PAREN_CLOSE:         ")">
|  <SQUARE_OPEN:         "[">
|  <SQUARE_CLOSE:        "]">
|  <CURLY_OPEN:          "{">
|  <CURLY_CLOSE:         "}">
|  <EQUAL:               "=" | "==">
|  <UNEQUAL:             "<>" | "!=">
|  <LESS:                "<">
|  <GREATER:             ">">
|  <LESS_OR_EQ:          "<=">
|  <GREATER_OR_EQ:       ">=">
|  <AGGREGATE_COUNT:     "#count">
|  <AGGREGATE_MAX:       "#max">
|  <AGGREGATE_MIN:       "#min">
|  <MINIMIZE:            "#minimi"["z","s"]"e">
|  <MAXIMIZE:            "#maximi"["z","s"]"e">
|  <AGGREGATE_SUM:       "#sum">
|  <AGGREGATE_SUM_PLUS:  "#sum+">
|  <AGGREGATE_TIMES:     "#times">
|  <CLINGO_SHOW: 	     "#show " (["a"-"z"] ( ["A"-"Z", "a"-"z", "0"-"9","_"] )*) "/" ("0" | ["1"-"9"](["0"-"9"])*)>
|  <META_MAXINT: 	     "#maxint" " = " ("0" | ["1"-"9"](["0"-"9"])*)>
|  <META_CONST: 	     "#const " (["a"-"z"] ( ["A"-"Z", "a"-"z", "0"-"9","_"] )+) " = " (( ["A"-"Z", "a"-"z", "0"-"9","_"] )+) >
|  <DLV_ARITHMETIC_ID:	 "#"("succ"|"prec"|"mod")>
|  <DLV_ID: 			 "#"("rand"|"int"|"absdiff"|"append"|"delnth"|"flatten"|"getnth"|"head"|"insLast"|"insnth"|"last"|"length"|"member"|"reverse"|"subList"|"tail")>
|  <META_OTHER:			 "#"(["a"-"z"] ( ["A"-"Z", "a"-"z", "0"-"9","_","="] )*)>
}

ASTAnswerSet AnswerSet() #AnswerSet:
{}
  {
     (
     (ClassicalLiteral())* 
     )
     { return jjtThis; }
  }
  
ASTProgram Program() #Program:
{}
  {
     ([LOOKAHEAD(<CONS> | <WCONS> | Head() | Optimize() <DOT> | <CLINGO_SHOW> | <META_MAXINT> | <META_CONST> | <META_OTHER>) Statements()] 
     [Query()]
     <EOF>)
     { return jjtThis; }
  }

ASTRuleList Statements() #RuleList:
{}
{
  (LOOKAHEAD(Statement()) Statement())+ 
   { return jjtThis; }
}

ASTQuery Query() #Query:
{}
{
  ( ClassicalLiteral() <QUERY_MARK> )
  { return jjtThis; }
}

ASTRule Statement() #Rule:
{}
{
  (
  (<CONS> [Body()] <DOT>)
  | (Head() [<CONS> [Body()]] <DOT>)
  | (<WCONS> [Body()] <DOT> <SQUARE_OPEN> WeightAtLevel() <SQUARE_CLOSE>)
  | (Optimize() <DOT>)
  | (MetaStatement() <DOT>)
  )
  
  { return jjtThis; }
}

ASTHead Head() #Head:
{}
{
  (
  LOOKAHEAD([Term() Binop()] <CURLY_OPEN>) (Choice())
  | LOOKAHEAD(3)(Disjunction())
  | (Aggregate())
  )
  
  { return jjtThis; }
}

ASTBodyList Body() #BodyList:
{}
{
  (
  (LOOKAHEAD(Body1() <COMMA>) Body1() <COMMA>)* Body1()
  )
  { return jjtThis; }
}

ASTBody Body1() #Body: {}
{
  (
  LOOKAHEAD([<NAF>] [Term() Binop()] AggregateFunction()) [<NAF>{jjtThis.nafneg(true);}] Aggregate()
  | NAFLiteral()
  )
  
  { return jjtThis; }
}

ASTHeadElementsList Disjunction() #HeadElementsList:
{}
{
  (
  (LOOKAHEAD(ClassicalLiteral() <OR>) ClassicalLiteral() <OR>)* ClassicalLiteral()
  )
  { return jjtThis; }
}

ASTChoice Choice() #Choice:
{}
{
  (
  [Term() Binop()] <CURLY_OPEN> [ChoiceElements()] <CURLY_CLOSE> [Binop() Term()]
  )
  { return jjtThis; }
}

ASTChoiceElementList ChoiceElements() #ChoiceElementList:
{}
{
  (
  (LOOKAHEAD(ChoiceElement() <SEMICOLON>) ChoiceElement() <SEMICOLON>)* ChoiceElement()
  )
  { return jjtThis; }
}

ASTChoiceElement ChoiceElement() #ChoiceElement:
{}
{
  ( ClassicalLiteral() [<COLON> [NAFLiterals()]] )
  { return jjtThis; }
}

ASTAggregate Aggregate() #Aggregate:
{}
{
  (
  [Term() Binop()] AggregateFunction() <CURLY_OPEN> AggregateElements()
  <CURLY_CLOSE> [Binop() Term()]
  )
  { return jjtThis; }
}

ASTAggrElementList AggregateElements() #AggrElementList:
{}
{
  (
  (LOOKAHEAD(AggregateElement() <SEMICOLON>) AggregateElement() <SEMICOLON>)* AggregateElement()
  )
  { return jjtThis; }
}

ASTAggrElement AggregateElement() #AggrElement:
{}
{
  (
  [Terms()] [<COLON> [NAFLiterals()]]
  )
  { return jjtThis; }
}

String AggregateFunction() #AggrFunc:
{}
{
  ( <AGGREGATE_COUNT>
  | <AGGREGATE_MAX>
  | <AGGREGATE_MIN>
  | <AGGREGATE_SUM_PLUS> 
  | <AGGREGATE_SUM> 
  | <AGGREGATE_TIMES>
  )
 
  { 
  	jjtThis.func(this.token.image);
  	return this.token.image; }
}

void MetaStatement() #ClingoMeta:
{}
{
  ( <CLINGO_SHOW> 
  | <META_MAXINT> 
  | <META_CONST> 
  | <META_OTHER> )
  { 
  	 jjtThis.statement(this.token.image); }
}

ASTOpt Optimize() #Opt:
{}
{
  (
  OptimizeFunction() <CURLY_OPEN> [OptimizeElements()] <CURLY_CLOSE>
  )
   { return jjtThis; }
}

ASTOptElementList OptimizeElements() #OptElementList :
{}
{
  (
  (LOOKAHEAD(OptimizeElement() <SEMICOLON>) OptimizeElement() <SEMICOLON>)* OptimizeElement() 
  )
  { return jjtThis; }
}

ASTOptElement OptimizeElement() #OptElement:
{}
{
  (WeightAtLevel() [<COLON> [NAFLiterals()]])
   { return jjtThis; }
}

String OptimizeFunction() #OptFunc:
{}
{
  ( (<MAXIMIZE> {jjtThis.maximize(true);}) | (<MINIMIZE>) )
  
  { 
  	jjtThis.func(this.token.image);
  	return this.token.image; }
}

ASTWeight WeightAtLevel() #Weight:
{}
{
   ( Term() [<AT> Term() {jjtThis.hasLevel(true);}] [<COMMA> Terms()] )
   { return jjtThis; }
}

ASTNAFLiteralList NAFLiterals() #NAFLiteralList:
{}
{
  (
  (LOOKAHEAD(NAFLiteral() <COMMA>) NAFLiteral() <COMMA>)* NAFLiteral()
  )
  
   { return jjtThis; }
}

ASTNAFLiteral NAFLiteral() #NAFLiteral:
{}
{
 ( [<NAF>{jjtThis.nafneg(true);}] 
  (LOOKAHEAD((Term() Binop() Term()) | (Binop()) | (DlvArithmeticPredicate() <PAREN_OPEN> Terms() <PAREN_CLOSE>) | Arithop() <PAREN_OPEN> Term() <COMMA>) BuiltinAtom()
 | ClassicalLiteral() )
 )
 
  { return jjtThis; }
}
ASTLiteral ClassicalLiteral() #Literal:
{}
{
  ( 
  [(<MINUS>{jjtThis.neg(true);})] (Identifier() | DlvIdentifier()) [<PAREN_OPEN> [Terms()] <PAREN_CLOSE>] 
  )
  { return jjtThis; }
}

ASTBuiltInAtom BuiltinAtom() #BuiltInAtom :
{}
{
  (
  LOOKAHEAD(4)(Term() Binop() Term())
  | (Binop() <PAREN_OPEN> Term() <COMMA> Term() <PAREN_CLOSE>)
  | (DlvArithmeticPredicate() <PAREN_OPEN> Terms() <PAREN_CLOSE>)
  | Arithop() <PAREN_OPEN> Term() <COMMA> Term() <COMMA> Term() <PAREN_CLOSE>
  )
  { return jjtThis; }
}

String Binop() #Binop:
{}
{
  (
  <EQUAL>
  | <UNEQUAL>
  | <LESS>
  | <GREATER>
  | <LESS_OR_EQ>
  | <GREATER_OR_EQ>
  )
  { 
  	jjtThis.op(this.token.image);
  	return this.token.image; }
}

ASTTermList Terms() #TermList:
{}
{
  (
  (LOOKAHEAD(Term() <COMMA>) Term() <COMMA>)* Term()
  )
  { return jjtThis; }
}

ASTTerm Term() #Term:
{ Token t; }
{
  ( (Identifier() [<PAREN_OPEN> [Terms()] <PAREN_CLOSE>] AriTerm() )
  | (Number() AriTerm())
  | (String() AriTerm())
  | (Variable() AriTerm())
  | (<PAREN_OPEN> Term() <PAREN_CLOSE> AriTerm())
  | ((<MINUS>{jjtThis.neg(true);}) Term() AriTerm())  )
  
  { return jjtThis; }
}

ASTAriTerm AriTerm() #AriTerm : 
{ String t = "";}
{
  ([LOOKAHEAD(2)(t =Arithop()) Term()])
  { 
  jjtThis.op(t);
  return jjtThis; 
  }
}

String Arithop() #Arithop:
{}
{
  (
  <PLUS>
  | <MINUS>
  | <TIMES>
  | <DIV>
  | <MODULO>
  )
  { 
    jjtThis.op(this.token.image);
  	return this.token.image; }
}

void Number() #Number :
{ 
	Token t;
}
{
	(t=<NUMBER>)
	{ jjtThis.number(t.image); }
}

void Variable() #Var :
{ Token t; }
{
 (t=<VARIABLE> | t=<ANONYMOUS_VARIABLE>)
 	{
		jjtThis.name(t.image);
	}
}

void Identifier() #ID : 
{
	Token t;
} 
{
	(t=<ID>)
	{
		jjtThis.name(t.image);
	}
}

void DlvIdentifier() #DlvID : 
{
	Token t;
} 
{
	(t=<DLV_ID>)
	{
		jjtThis.name(t.image);
	}
}

void DlvArithmeticPredicate() #DlvArithmeticID : 
{
	Token t;
} 
{
	(t=<DLV_ARITHMETIC_ID>)
	{
		jjtThis.name(t.image);
	}
}

void String() #String : 
{
	Token t;
} 
{
	(t= <STRING>)
	{
		jjtThis.name(t.image);
	}
}
